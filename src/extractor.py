from capstone import *
import pandas as pd
import pefile
import os

"""
This module contains the functions to extract features from Portable Executable files.

"""

def extract_features(path):

    """
    Extracts features from a Portable Executable file using the pefile library.
    It extracts 42 features from the PE file.
 
    """

    # Check if the file is a valid PE file
    try:
        sample = pefile.PE(path)
    except Exception as e:
        return None

    # Define the features dictionary and add the name of the file
    features = {}
    features['Name'] = path.split('\\')[-1]

    # Define the features to extract from the PE file
    attributes = [
        'OPTIONAL_HEADER.CheckSum', 'FILE_HEADER.Machine', 'FILE_HEADER.SizeOfOptionalHeader',
        'FILE_HEADER.Characteristics', 'OPTIONAL_HEADER.MajorLinkerVersion', 'OPTIONAL_HEADER.MinorLinkerVersion',
        'OPTIONAL_HEADER.SizeOfCode', 'OPTIONAL_HEADER.SizeOfInitializedData', 'OPTIONAL_HEADER.SizeOfUninitializedData',
        'OPTIONAL_HEADER.AddressOfEntryPoint', 'OPTIONAL_HEADER.BaseOfCode', 'OPTIONAL_HEADER.BaseOfData',
        'OPTIONAL_HEADER.ImageBase', 'OPTIONAL_HEADER.SectionAlignment', 'OPTIONAL_HEADER.FileAlignment',
        'OPTIONAL_HEADER.MajorOperatingSystemVersion', 'OPTIONAL_HEADER.MinorOperatingSystemVersion',
        'OPTIONAL_HEADER.MajorImageVersion', 'OPTIONAL_HEADER.MinorImageVersion', 'OPTIONAL_HEADER.MajorSubsystemVersion',
        'OPTIONAL_HEADER.MinorSubsystemVersion', 'OPTIONAL_HEADER.SizeOfImage', 'OPTIONAL_HEADER.SizeOfHeaders',
        'OPTIONAL_HEADER.CheckSum', 'OPTIONAL_HEADER.Subsystem', 'OPTIONAL_HEADER.DllCharacteristics',
        'OPTIONAL_HEADER.SizeOfStackReserve', 'OPTIONAL_HEADER.SizeOfStackCommit', 'OPTIONAL_HEADER.SizeOfHeapReserve',
        'OPTIONAL_HEADER.SizeOfHeapCommit', 'OPTIONAL_HEADER.LoaderFlags', 'OPTIONAL_HEADER.NumberOfRvaAndSizes',
        'FILE_HEADER.NumberOfSections'
    ]

    # Add the features to the dictionary
    for attr in attributes:
        parts = attr.split('.')
        obj = sample
        for part in parts:
            if hasattr(obj, part):
                obj = getattr(obj, part)
            else:
                obj = None
                break
        if obj is not None:
            features[attr] = obj
        else:
            features[attr] = 0

    # Extract the entropy, raw size and virtual size of the sections
    MeanEntropy, MaxEntropy, MinEntropy = [], [], []
    MeanRawsize, MaxRawsize, MinRawsize = [], [], []
    MeanVirtualsize, MaxVirtualsize, MinVirtualsize = [], [], []

    for section in sample.sections:
        MeanEntropy.append(section.get_entropy())
        MeanRawsize.append(section.SizeOfRawData)
        MeanVirtualsize.append(section.Misc_VirtualSize)
        MaxEntropy.append(section.get_entropy())
        MaxRawsize.append(section.SizeOfRawData)
        MaxVirtualsize.append(section.Misc_VirtualSize)
        MinEntropy.append(section.get_entropy())
        MinRawsize.append(section.SizeOfRawData)
        MinVirtualsize.append(section.Misc_VirtualSize)

    # Calculate the mean, max and min of the entropy, raw size and virtual size
    try:
        features['MeanEntropy'] = sum(MeanEntropy) / float(len(MeanEntropy))
        features['MaxEntropy'] = max(MaxEntropy)
        features['MinEntropy'] = min(MinEntropy)
    except:
        features['MeanEntropy'] = 0
        features['MaxEntropy'] = 0
        features['MinEntropy'] = 0

    # Calculate the mean, max and min of the raw size
    try:
        features['MeanRawsize'] = sum(MeanRawsize) / float(len(MeanRawsize))
        features['MaxRawsize'] = max(MaxRawsize)
        features['MinRawsize'] = min(MinRawsize)
    except:
        features['MeanRawsize'] = 0
        features['MaxRawsize'] = 0
        features['MinRawsize'] = 0

    # Calculate the mean, max and min of the virtual size
    try:
        features['MeanVirtualsize'] = sum(MeanVirtualsize) / float(len(MeanVirtualsize))
        features['MaxVirtualsize'] = max(MaxVirtualsize)
        features['MinVirtualsize'] = min(MinVirtualsize)
    except:
        features['MeanVirtualsize'] = 0
        features['MaxVirtualsize'] = 0
        features['MinVirtualsize'] = 0

    # Extract the number of imports and the number of DLLs
    try:
        # Extract number of DLLs imported from the PE file
        features['ImportsNbDLL'] = len(sample.DIRECTORY_ENTRY_IMPORT)
        
        # Extract number of imports from each DLL
        import_count = 0
        for entry in sample.DIRECTORY_ENTRY_IMPORT:
            import_count += len(entry.imports)

        features['ImportsNb'] = import_count

        # Extracting the imports names
        imports = []
        for entry in sample.DIRECTORY_ENTRY_IMPORT:
            for imp in entry.imports:
                imports.append(imp.name.decode('utf-8'))

        # Add the imports to the dictionary
        features['DLLImports'] = ' '.join(imports)
    except:
        features['ImportsNbDLL'] = 0
        features['ImportsNb'] = 0
        features['DLLImports'] = ''

    # Extracting the opcodes from the code sections
    try:
        opcodes = []

        # Locate the code sections and extract the opcodes
        for section in sample.sections:
            if section.Characteristics & 0x20:
                code = section.get_data()

                # decode the code and print the disassembled code
                disassembler = Cs(CS_ARCH_X86, CS_MODE_32)
                for instruction in disassembler.disasm(code, section.VirtualAddress):
                    opcodes.append(instruction.mnemonic)

        # Add the opcodes to the dictionary
        features['Opcodes'] = ' '.join(opcodes)
    except:
        features['Opcodes'] = ''

    # stop the pefile module
    sample.close()

    return features