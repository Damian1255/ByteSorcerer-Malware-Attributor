import os
from flask import Flask, render_template, request, jsonify
from werkzeug.utils import secure_filename
import src.static.static as static_analysis
import src.binlex.binlex as binlex_analysis


# Initialize Flask app
app = Flask(__name__, static_url_path='/static')
app.config.from_pyfile(os.path.join(".", "config/app.conf"), silent=False)


# Home route
@app.route('/')
def home():
    return render_template('index.html')


@app.route('/staticmodel', methods=['GET', 'POST'])
def static_model():
    if request.method == 'POST':

        # Process the file from the request
        upload = process_file_from_request(request)
        if not upload['valid']:
            return jsonify({'success': False, 'message': upload['message']})
        
        try:
            # Get the file path from the upload
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], upload['filename'])

            # Process the file to extract features
            features = static_analysis.extract_features(file_path)

            # Delete the file from the server after processing
            os.remove(file_path)

            # Preprocess the features
            features = static_analysis.preprocess_data(features)

            # Predict the class of the file
            results = static_analysis.predict(features)
        
            return jsonify({'success': True, 'results': results, 'method': 'static'})
        
        except Exception as e:

            message = 'We are unable to process the file, try a different file.'
            return jsonify({'success': False, 'message': message})
        
    return render_template('index.html')


@app.route('/binlexmodel', methods=['GET', 'POST'])
def binlex():
    if request.method == 'POST':

        # Process the file from the request
        upload = process_file_from_request(request)
        if not upload['valid']:
            return jsonify(upload)
        
        try:
            # Get the file path from the upload
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], upload['filename'])
            
            # Process the file to extract features
            traits = binlex_analysis.extract_traits(file_path)

            # Delete the file from the server after processing
            os.remove(file_path)

            # Predict the class of the file
            results = binlex_analysis.analyze_traits(traits, n=200)
            
            return jsonify({'success': True, 'results': results, 'method': 'traits'})
        
        except Exception as e:

            message = 'We are unable to process the file, try a different file.'
            return jsonify({'success': False, 'message': message})
        
    return render_template('index.html')


@app.route('/status', methods=['GET'])
def status():
    return jsonify({'success': True, 'message': 'Test route works.'})


# Error handling for file size
@app.errorhandler(413)
def request_entity_too_large(error):
    message = 'The file uploaded has exceeded the maximum allowed size of 100MB.'
    return jsonify({'success': False, 'message': message})


# Process the file from the request and save it
def process_file_from_request(request):
    for item in request.files.getlist('file'):
        if item:
            imagename = secure_filename(item.filename)

            # Check if the file is blacklisted
            if '.' in imagename and imagename.rsplit('.', 1)[1].lower() in app.config['BLACKLISTED_EXTENSION']:
                message = """The file uploaded is not supported.
                            Ensure you are uploading an Portable Executable file."""
                return {'valid': False, 'message': message}
        
            # Save the file for processing
            item.save(os.path.join(app.config['UPLOAD_FOLDER'], imagename))

            return {'valid': True, 'filename': imagename}
        else:
            return {'valid': False, 'message': 'No file is uploaded.'}
        

if __name__ == '__main__':
    app.run(debug=True)

